/** {*/
/*  border: 1px solid red;*/
/*}*/

/*.header-section {*/
/*  background: orange;*/
/*}*/
.nav-menu__link.w--current {
  color: white;
}

.fan-nav__menu {
  /*height: 100vh;*/
  /*overflow-y: scroll;*/
}

.fan-nav-scroll.hide {
  transform: translateY(-100%);
}

.fan-nav__menu-wrapper {
  height: 100vh;
  overflow: hidden;
}

.smooth-scroll {
  will-change: transform;
}

/* NAV */
.w-container {
  max-width: unset;
}

.w-nav[data-collapse="all"] .w-nav-button {
  display: flex;
}

.w-nav-button {
  font-size: unset;

}

.navbar_button.show .navbar_section-wrapper {
  width: 100%;
}

.navbar_section-wrapper {
  height: 1.7rem;
  overflow: hidden;
  width: 0;
}

.navbar_section-wrapper.ghost-nav {
  height: auto;
  z-index: -5;
  /*display: none;*/
  opacity: 0;
}

[data-nav-menu-open] {
  top: 0;
}

.navbar_section-wrapper.ghost-nav.test {
  height: auto;
  z-index: 5;
}

.navbar_section-wrapper.ghost-nav .navbar_section-text,
.fan-nav_section-wrapper.ghost-nav .navbar_section-text {
  width: fit-content;
}

.w-nav-overlay {
  top: 0;
}

/*.navbar_sections-wrapper {*/
/*width: 0;*/
/*overflow: hidden;*/
/*  position: absolute;*/
/*  right: 100%;*/
/*  top: 100%;*/
/*}*/

.navbar_section {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  /*border: 1px solid white;*/

}

.navbar_section-text {
  width: 0;
  /*border: 1px solid blue;*/
  /*height: 1.7rem;*/
  /*width: 0;*/
  /*height: 0;*/
  /*transition: height 0.3s ease;*/
  /*overflow: hidden;*/
}

.navbar_section-text.isActive {
  width: fit-content;
  transition: width 0.3s ease;
  transition-delay: 3;
  /*border: 2px solid lime;*/

}

.navbar_sections-inner {
  /*position: absolute;*/
  /*width: 0;*/
}

/*.navbar_button_lines {*/
/*  padding-left: 1em;*/

/*}*/

.navbar_button {
  width: 4rem;
  height: 4rem;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
}

.navbar_button {
  width: auto;
  height: auto;
  display: unset;
  justify-content: center;
  align-items: center;
  overflow: unset;
}

.navbar_button.showTagline .navbar_sections-inner .navbar_section:nth-of-type(1) {
  background: purple;
}

.navbar_button.showTagline .navbar_sections-wrapper {
  width: 100%;
}

.navbar_section-text {}

/* END NAV */

.section-header-text,
.stacked-title,
.typing-text,
.cursor .font-size-xxl,
.impact-h1 {
  font-size: clamp(8.5rem, 3rem + 3vw, 12.5rem);
  /*200px - 60px*/
  font-size: clamp(3.75rem, 2.0833rem + 8.3333vw, 12.5rem);
  font-size: clamp(4.0625rem, 2.4554rem + 8.0357vw, 12.5rem);
  /*font-size: clamp(4.375rem, 2.8274rem + 7.7381vw, 12.5rem);*/
}

svg {
  max-width: 100%;
}

.line-reveal-btn {
  position: absolute;
  width: 100%;
}

.text-reveal-content {
  /*border: 1px solid red;*/
  opacity: 1;
}

.padding-section-large {
  /*background: purple;*/
}

.page-header-video-overlay::after {
  position: absolute;
  content: "";
  width: 100%;
  height: 5rem;
  background: #000;
  bottom: -1em;
  /*border: 1px solid red;*/
}

.line-item__inner {
  display: inline-block;
  transition: transform 0.15s ease-out;
}

.text-reveal-content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.kinetic-svg {
  overflow: visible !important;
}

.section-reveal_background {
  will-change: transform;
}

.section-fade-up {
  opacity: 0;
  transform: translateY(50px);
}

.definition {
  /*position: absolute;*/
  /*transform: translateY(50px);*/
  position: absolute;
  transform: translateY(50px);
  left: 0;

}

.logo-path-svg svg,
{
max-width: 10rem;
}

.accordion-title.active {
  font-size: clamp(8rem, 3.0865rem + 9.1308vw, 12.5rem);
  font-size: clamp(5.625rem, 3.9345rem + 8.4524vw, 14.5rem);
  font-size: clamp(4.375rem, 2.4464rem + 9.6429vw, 14.5rem);
  font-size: clamp(4.0625rem, 2.0744rem + 9.9405vw, 14.5rem);
}

/*logo slide*/

.section_logo1 svg,
.section_icon-slide svg {
  max-width: unset;
}

.logo-content-center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}

/*.logo-content_wrap {*/
/*  position: absolute;*/
/*  top: 50%;*/
/*  left: 50%;*/
/*  transform: translate(-50%, -50%);*/

/*}*/

.logo-list_inner {
  position: relative;
  overflow: hidden;
  /* Prevents overflow */
}

.logo-list-wrapper::before,
.logo-list-wrapper::after,
.icon-list-wrapper::before,
.icon-list-wrapper::after {
  content: "";
  position: absolute;
  top: 0;
  width: 30%;
  /* Adjust as needed */
  height: 100%;
  pointer-events: none;
  z-index: 2;
}

.section_logo1 .logo-list-wrapper::before {
  left: 0;
  background: linear-gradient(to right, white 0%, transparent 100%);
}

.section_logo1 .logo-list-wrapper::after {
  right: 0;
  background: linear-gradient(to left, white 0%, transparent 100%);
}

.color-panel .colors-content {
  opacity: 0;

  clip-path: inset(0 0 0 0);
  transition: clip-path 0.3s ease;
  overflow: hidden;
  transition: all 0.2s ease-out;
}

.color-panel.active {
  border: 1px solid lime;
}

.color-panel.active .colors-content {
  opacity: 1;

}

.stacked-slide {
  position: absolute;
}

.stacked-slider {
  height: 100vh;
}

.stacked-img {
  clip-path: inset(0% 0% 0% 0%);
}

#section-header-test {
  /*overflow: hidden;*/
}

#section-header-number-small {
  color: #e10600;
  opacity: 1;
  font-size: 3rem;
  display: flex;
  justify-content: center;
  align-items: center;
}

#section-header-text-large {
  font-size: 12vw;
}

.section-typography .fan-sans-svg {
  width: 100%;
  fill: white;
}

.fan-sans-lottie-section .lottie-text-fade .heading-style-h2 {
  /*border: 1px solid red;*/
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.5s ease;
}

.fan-sans-lottie-section .background-block {
  width: 0%;
  transform-origin: center center;
  transition: none;
}

/*@media screen and (max-width:991px) {*/
/*  .fan-sans-lottie-section .lottie-text-fade .heading-style-h2 {*/
/*    bottom: 0;*/
/*  }*/
/*}*/

.fan-sans-lottie-section .lottie-text-fade .heading-style-h2.active {
  opacity: 1;
  pointer-events: auto;
}

.typography-fans-svg {
  /*clip-path: inset(0 100% 0 0);*/
}

/*scroll slider*/
.scrolling-slider_slides {
  /*transform: translateX(100vw);*/
}

/*.section-tagline {*/
/*  position: relative;*/
/*}*/

/*.tagline-pin {*/
/*  position: relative;*/
/*  z-index: 5;*/
/*}*/

/*.section-tagline .section-header {*/
/*  position: relative;*/
/*  z-index: 0;*/
/*}*/

/*.section-wipe {*/
/*  position: absolute;*/
/*  top: 0;*/
/*  left: 0;*/
/*  width: 100%;*/
/*  height: 100%;*/
/*  background: #fff;*/
/*  z-index: 10;*/
/*}*/

/*.section-tagline .header-section.background-color-black {*/
/*  position: absolute;*/
/*  top: 0;*/
/*  left: 0;*/
/*  width: 100%;*/
/*  z-index: 0;*/

/*}*/

//js 
console.log('loaded phase 1!!');

gsap.registerPlugin(ScrollTrigger, TextPlugin, SplitText, DrawSVGPlugin, ScrollSmoother,
  GSDevTools, Flip);

const lenis = new Lenis({
  duration: 1.2, // Adjust smooth scrolling speed
  easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)), // Smooth easing function
  smooth: true,
  wheelMultiplier: 0.7,
});

function raf(time) {
  lenis.raf(time);
  requestAnimationFrame(raf);
}
requestAnimationFrame(raf);

// Tell ScrollTrigger to update when Lenis scrolls
lenis.on("scroll", () => ScrollTrigger.update());

// Display the body (optional if you had it hidden in CSS)
document.querySelector('body').style.display = "block";

// const isMobile = window.matchMedia("(max-width: 768px)").matches;

// Fade in the body after scripts load
gsap.fromTo('body', { opacity: 0 }, { opacity: 1, duration: 0.5 });

let fanNav = document.querySelector('.fan-nav')
let navButton = fanNav.querySelector('.fan-nav__button');

let menu = fanNav.querySelector('.fan-nav__menu');

const sectionLinks = Array.from(fanNav.querySelectorAll('.nav-menu__link[section]'));

document.querySelectorAll('.fan-nav .nav-menu__link').forEach(link => {
  // console.log(link)
  link.addEventListener('click', e => {
    e.preventDefault();
    e.stopPropagation();
    console.log('clicked')
    const targetID = link.getAttribute('href');
    const targetElem = document.querySelector(targetID);
    if (!targetElem) return;
    // BLUR LOOKS COOL BUT BREAKS NAV FOR SOME REASON
    // gsap.to('body', {
    //   filter: "blur(2px)"
    // })
    gsap.to('body', {
      opacity: 0,
      duration: 0.1,

      onComplete() {
        // 1 toggle nav open/closed
        toggleMenu();

        // 2 smooth scroll
        lenis.scrollTo(targetElem, {
          offset: 0,
          duration: 1.2,
          lock: true,
          onComplete() {
            // 3 fade body back in
            gsap.to('body', { opacity: 1, duration: 0.3 });
          }
        });
      }
    });

  })
})

// have to se navbar to close after
// document.querySelectorAll('.fan-nav .nav-menu__link').forEach(link => {
//   console.log(link)
//   link.addEventListener('click', e => {
//     e.preventDefault();
//     e.stopPropagation();
//     console.log('clicked')
//     const targetID = link.getAttribute('href');
//     const targetElem = document.querySelector(targetID);
//     if (!targetElem) return;
//     // BLUR LOOKS COOL BUT BREAKS NAV FOR SOME REASON
//     // gsap.to('body', {
//     //   filter: "blur(2px)"
//     // })
//     gsap.to('body', {
//       opacity: 0
//     })
//     toggleMenu()

//     setTimeout(() => {
//       lenis.scrollTo(targetElem, {
//         offset: 0, // e.g. 100 if you want to offset for a fixed header
//         // duration: 1.2, // override default speed
//         lock: false, // optional
//         onComplete() {
//           // gsap.to('body', {
//           //   filter: "blur(0px)"
//           // })
//           gsap.to('body', {
//             opacity: 1
//           })
//         }

//       });
//     }, 50);

//   })
// })

function throttle(fn, wait) {
  let lastTime = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastTime >= wait) {
      lastTime = now;
      fn.apply(this, args);
    }
  };
}

function toggleMenu() {
  let logo = fanNav.querySelector('.fan-nav__logo')
  let isOpen = navButton.getAttribute('aria-expanded') === 'true' || false;

  if (isOpen) {
    hideMenu();
  } else {
    showMenu();
  }

  function showMenu() {
    isOpen = true;
    navButton.setAttribute('aria-expanded', true);

    // Disable native scrolling
    document.body.style.overflow = 'hidden';

    // Stop Lenis from intercepting scroll
    // lenis.stop();

    let tl = gsap.timeline();
    tl.to(menu, {
      y: 0
    }, "<");

    tl.to(logo, {
      opacity: 1
    }, "<");
    gsap.set(fanNav.querySelector('.fan-nav-container'), {
      backgroundColor: "#e10600"
    })
  }

  function hideMenu() {
    isOpen = false;
    navButton.setAttribute('aria-expanded', false);

    // Re-enable native scrolling
    document.body.style.overflow = '';

    // Restart Lenis so scrolling works again
    // lenis.start();

    let tl = gsap.timeline();
    tl.to(menu, {
      y: `-100%`
    });

    tl.to(logo, {
      opacity: 0
    }, "<");
    tl.to(fanNav.querySelector('.fan-nav-container'), {
      backgroundColor: "unset"
    }, "<");
  }
}

function updateActiveLink(sectionVal) {
  sectionLinks.forEach(link => {
    const val = +link.getAttribute('section');
    link.classList.toggle('active', val === sectionVal);
  });
}

const throttledToggle = throttle(toggleMenu, 200);

function navbar() {

  let navContainerHeight = fanNav.querySelector('.fan-nav-container').getBoundingClientRect()
    .height;

  let navSectionsInner = navButton.querySelector('.navbar_sections');
  let navHeaders = navButton.querySelectorAll('.navbar_section-text');

  let navHeaderSections = navButton.querySelectorAll('.navbar_section');
  let navbarSectionWrapper = navButton.querySelector('.navbar_section-wrapper');
  let navbarIcon = navButton.querySelector('.navbar_button_lines');

  // console.log(sectionLinks)

  // issue here on 1791x751
  gsap.set(menu.querySelector('.nav-menu__inner'), {
    paddingTop: `calc(${navContainerHeight}px + 2rem)`
  })

  // gsap.set(menu, {
  //   yPercent: -100
  // })

  // clone ghostNav
  // let ghostNav = document.createElement('div');
  // ghostNav.classList.add('ghost-nav');

  // let clonedSections = navSectionsInner.cloneNode(true)

  // ghostNav.appendChild(clonedSections)

  // fanNav.prepend(ghostNav)

  let ghostNav = document.querySelector('.ghost-nav');
  let ghostNavItems = ghostNav.querySelectorAll('.navbar_section-text');
  console.log(`ghostNavItems`)
  console.log(ghostNavItems)
  const ghostWidths = [...ghostNavItems].map(el => el.getBoundingClientRect().width);
  const headerWidths = [...navHeaders].map(el => el.getBoundingClientRect().width);
  console.log(`ghostWidths`)
  console.log(ghostWidths)

  headerWidths[0] = 0;
  ghostWidths[0] = 0;

  let recalcCount = 0;

  function measureWidths() {
    recalcCount++;
    ghostWidths.length = 0;
    headerWidths.length = 0;

    ghostNavItems.forEach(el => ghostWidths.push(el.getBoundingClientRect().width));
    navHeaders.forEach(el => headerWidths.push(el.getBoundingClientRect().width));

    // keep the first slot 0 for the icon-only state
    ghostWidths[0] = 0;
    headerWidths[0] = 0;

  }

  // gsap.set(navHeaders[0], { width: 0 });

  // Get consistent navbar height from the icon.
  let navbarHeight = document.querySelector('.navbar_icon').getBoundingClientRect().height;
  gsap.set(navbarSectionWrapper, { height: navbarHeight });
  gsap.set(navHeaderSections, { height: navbarHeight });

  gsap.set(navSectionsInner, { height: navbarHeight * navHeaders.length });

  const fraction = 100 / navHeaders.length;
  let sliderIndex = 0;

  // Initially, mark only the first nav header as active.
  navHeaders.forEach((header, j) => {
    header.classList.toggle('isActive', j === sliderIndex);
  });

  // Query all sections that have your custom "section-head" attribute.
  const sectionHeads = document.querySelectorAll("[section-head]");

  // console.log(`navHeaders: ${navHeaders.length}`)
  // console.log(`sectionHeads: ${sectionHeads.length}`)
  // console.log(`ghostNavItems: ${ghostNavItems.length}`)

  function animateActiveHeader(index, ghostWidth) {
    const activeHeader = navHeaders[index];
    // set it to its â€œinitialâ€ width (preâ€‘measured)
    gsap.set(activeHeader, { width: headerWidths[index] + "px" });
    // then tween to the ghost width
    gsap.to(activeHeader, {
      width: ghostWidth + "px",
      duration: 0.3,
      ease: "power4.out",
      onComplete: () => {
        navHeaders.forEach((hdr, idx) => {
          hdr.classList.toggle("isActive", idx === index);
        });
      }
    });
  }

  function animateSection(sectionVal, ghostWidth) {
    // 1) compute new sliderIndex
    // sliderIndex = Math.min(sectionVal - 1, navHeaders.length - 1);
    sliderIndex = Math.min(sectionVal, navHeaders.length - 1);

    // 2) slide the navSectionsInner container
    gsap.to(navSectionsInner, {
      yPercent: -(sliderIndex * fraction),
      duration: 0.3,
      delay: 0.5,
      ease: "power4.out"
    });

    // 3) adjust the header width
    animateActiveHeader(sliderIndex, ghostWidth);
  }

  // For each section, create a ScrollTrigger timeline.
  sectionHeads.forEach((section, i) => {
    let ghostItemWidth = ghostWidths[i];
    let initialWidth = headerWidths[sliderIndex];
    // let ghostItemWidth = currentGhostNavItem.getBoundingClientRect().width;
    const sectionVal = +section.getAttribute("section");
    let tl = gsap.timeline({
      scrollTrigger: {
        trigger: section,
        start: "top-=50 top",
        end: "bottom top",
        toggleClass: {
          targets: ".navbar_section-wrapper.ghost-nav",
          className: "test"
        },
        refreshPriority: -1, // ensures this refreshes after others
        id: "Section " + i,
        // markers: {
        //   startColor: "lime",
        //   endColor: "fuchsia",
        //   fontSize: "16px",
        //   startLabel: "start - " + i,
        //   endLabel: "end - " + i,
        //   indent: 20
        // },
        // When scrolling down into a sectionâ€¦
        onEnter: () => {
          // console.log('entering')
          // remove class from prev active
          const prevActive = fanNav.querySelector('.nav-menu__link.active');
          if (prevActive) prevActive.classList.remove('active');

          // add active class to new active
          const newActive = fanNav.querySelector(
            `.nav-menu__link[section="${sectionVal}"]`);
          if (newActive) newActive.classList.add('active')

          const tl = gsap.timeline();
          sliderIndex = Math.min(sectionVal, navHeaders.length - 1);
          tl.to(navSectionsInner, {
            yPercent: -(sliderIndex * fraction),
            duration: 0.3,
            delay: .5,
            ease: "power4.out"
          });
          let activeHeader = navHeaders[sliderIndex];
          tl.set(activeHeader, { width: headerWidths[sliderIndex] + "px" }, "<");

          tl.to(activeHeader, {
            width: ghostItemWidth + "px",
            duration: 0.3,
            ease: "power4.out",
            onComplete: () => {
              // When complete, update active state.
              navHeaders.forEach((hdr, idx) => {
                hdr.classList.toggle("isActive", idx === sliderIndex);
              });
            }
          }, "<");

          updateActiveLink(sectionVal);

        },
        // When scrolling upwardâ€¦
        onEnterBack: () => {

          // sliderIndex = Math.min(sectionVal - 1, navHeaders.length - 1);
          sliderIndex = Math.min(sectionVal, navHeaders.length - 1);

          let activeHeader = navHeaders[sliderIndex];

          let currentWidth = activeHeader.offsetWidth;

          const tl = gsap.timeline();
          tl.to(navSectionsInner, {
            yPercent: -(sliderIndex * fraction),
            duration: 0.3,
            ease: "power4.out"
          })

          tl.set(activeHeader, { width: currentWidth + "px" });
          tl.to(activeHeader, {
            width: ghostItemWidth + "px",
            duration: 0.3,
            ease: "power4.out",
            onComplete: () => {
              navHeaders.forEach((hdr, idx) => {
                hdr.classList.toggle("isActive", idx === sliderIndex);
              });
            }
          });

          updateActiveLink(sectionVal);

        },
        toggleActions: "play none none reverse",
      }
    });
    tl.to(navbarSectionWrapper, {
      width: ghostItemWidth + "px",
      duration: 0.3
    });
  });

  navButton.addEventListener('click', throttledToggle);

  // navButton.addEventListener('click', (event) => {
  //   console.log('clicked!');
  // });
}

navbar();

function splitTextIntoWords(element, lineClass = 'line-item', innerClass = 'line-item__inner') {
  // Use GSAPâ€™s SplitText plugin
  const split = new SplitText(element, {
    type: 'words',
    linesClass: lineClass
  });

  // Wrap each word in .line-item__inner
  split.words.forEach((word) => {
    const innerSpan = document.createElement('span');
    innerSpan.classList.add(innerClass);
    innerSpan.innerHTML = word.innerHTML;
    word.innerHTML = '';
    word.appendChild(innerSpan);
  });

  // Return all the newly created .line-item__inner spans
  return element.querySelectorAll(`.${innerClass}`);
}

// Grab your elements
/*******************************************
  1) SPLIT TEXT INTO WORDS
     (Already done before revealText)
********************************************/
const textRevealWrapper = document.querySelector('.text-reveal-wrapper');
const textRevealContents = gsap.utils.toArray('.text-reveal-content');

// 1ï¸âƒ£ **SPLIT TEXT INTO WORDS**
textRevealContents.forEach((text) => {
  const lineReveal = text.querySelector('.line-reveal');
  if (!lineReveal) return;

  // Split into words
  const split = new SplitText(lineReveal, {
    type: 'words',
    linesClass: 'line-item'
  });

  // Wrap each word in a .line-item__inner <span>
  split.words.forEach((word) => {
    const innerSpan = document.createElement('span');
    innerSpan.classList.add('line-item__inner');
    innerSpan.innerHTML = word.innerHTML;
    word.innerHTML = '';
    word.appendChild(innerSpan);
  });
});

/*******************************************
  2) REVEAL TEXT
********************************************/
function revealText(textRevealWrapper, isPageHeader = false) {
  let textRevealContents = textRevealWrapper.querySelectorAll('.text-reveal-content')

  let direction = 1;
  let progress = 0;
  const revealMasterTl = gsap.timeline({
    scrollTrigger: {
      scroller: "body",
      trigger: textRevealWrapper,
      start: 'top top',
      end: () => `+=${textRevealContents.length * 1400}`,
      pin: true,
      scrub: 1,
      // KEY: Reverses on scroll up
      toggleActions: 'play none none reverse',
      // onEnter: loadFirstEl,
      onUpdate: self => {
        // progress = self.progress;
        // console.log(`progress ${progress}`)
        // if (self.direction !== self.prevDirection) {
        //   console.log("toggled!");
        //   self.prevDirection = self.direction;
        //   direction = self.direction;
        //   console.log(direction)
        // }
      }
    }
  });

  // if (isPageHeader) {
  //   let pageHeader = document.querySelector('.page-header')
  //   let logoVideo = pageHeader.querySelector('.logo-video')
  //   let flagVideo = pageHeader.querySelector('.flag-video')
  //   console.log(logoVideo)
  // }

  let pageHeader, logoVideo, flagVideo;

  if (isPageHeader) {
    pageHeader = document.querySelector('.page-header');
    logoVideo = pageHeader.querySelector('.logo-video');
    flagVideo = pageHeader.querySelector('.flag-video');

    gsap.set([logoVideo, flagVideo], {
      opacity: 1,
      y: 0,
      // border: "2px solid red"
    });

  }

  function loadFirstEl() {
    let tl = gsap.timeline()
    let firstContents = textRevealContents[0];
    let text = firstContents.querySelectorAll('.line-item__inner')
    // console.log
    tl.to(text, {
      border: "2px solid red",
      yPercent: 0,
      opacity: 1,
      duration: 1,
      stagger: 0.15,
      color: "white",
      ease: "power4.out"
    })
  }

  textRevealContents.forEach((text, i) => {
    const lineItemsInner = text.querySelectorAll('.line-item__inner');
    const svg = text.querySelector('.text-reveal-svg');
    const buttonGroup = text.querySelector('.line-reveal-btn');
    const hasSVGAnimation = text.hasAttribute('data-animate-svg');
    const fastSVGElement = document.querySelector('.fast-svg');
    const bigTextAnimation = textRevealContents[i].querySelector('.banner13_animation')
    const typographyFans = textRevealContents[i].querySelector('.typography-fans-svg');
    const fansSansTypography = text.querySelector('.fan-sans-svg')

    const endColor = textRevealWrapper.getAttribute('data-end-color') || '#ffffff';

    // ******************************************
    // 2) Universal initial states (for every item, including i===0)
    //    => ALL blocks start red (#E10600)
    // ******************************************
    gsap.set(lineItemsInner, {
      yPercent: 100,
      opacity: 0,
      color: "#E10600" // <--- each word starts red
    });
    if (svg) gsap.set(svg, { opacity: 0, y: 20 });
    if (fastSVGElement) gsap.set(fastSVGElement, { opacity: 0, scale: 0.8 });
    if (fansSansTypography) {
      gsap.set(fansSansTypography, { opacity: 0 })
    }

    // if (buttonGroup) gsap.set(buttonGroup, { opacity: 0, y: 20 });
    // (If you want the button group also hidden for i===0, re-uncomment above)

    const tl = gsap.timeline();

    //current
    if (i === 0) {
      // lines in
      tl.to(lineItemsInner, {
        yPercent: 0,
        opacity: 1,
        duration: 1,
        stagger: 0.15,
        color: endColor,
        ease: "power4.out"
      });
      // button in
      if (buttonGroup) {
        tl.to(buttonGroup, {
          y: 0,
          opacity: 1,
          duration: 0.5,
          ease: "power3.out"
        }, "-=0.5");
      }
    }

    if (typographyFans) {
      let typographyFansSVG = typographyFans.querySelector("svg");

      // Instead of a set + a .to(),
      // do a fromTo right in the timeline:
      tl.fromTo(
        typographyFansSVG,
        {
          // START STATE:
          // clipPath: "inset(0 100% 0 0)", // hide from the right
          xPercent: 250, // push it offscreen to the right
          skewX: 10, // tilt
          transformOrigin: "100% 50%", // pivot around right edge
          // opacity: 0
        },
        {
          // END STATE:
          xPercent: 0,
          clipPath: "inset(0 0 0 0)", // fully visible
          x: 0, // slide back to normal
          skewX: 0, // remove tilt
          duration: 10,
          ease: "power4.out"
        }
      );
    }

    if (bigTextAnimation) {
      let bigTextTop = bigTextAnimation.querySelector('.banner13_heading-top')
      let bigTextBtm = bigTextAnimation.querySelector('.banner13_heading-bottom')
      gsap.set(bigTextTop, { xPercent: 200 });
      gsap.set(bigTextBtm, { xPercent: -200 });

      // revealMasterTl.add(bigTextTl);
      tl.to(bigTextTop, {
        opacity: 1,
        xPercent: 15,
        duration: 2,
      })
      tl.to(bigTextBtm, {
        opacity: 1,
        xPercent: -15,
        duration: 2,
      }, "<")

      tl.to({}, { duration: 2 });

      tl.to(bigTextTop, {
        xPercent: 200, // send it back off-screen to the right
        // opacity: 0,
        duration: 2,
        ease: "power4.in"
      })
      tl.to(bigTextBtm, {
        xPercent: -200, // send it off-screen to the left
        // opacity: 0,
        duration: 2,
        ease: "power4.in"
      }, "<");
    }

    // **Animate IN** for each text block
    if (svg) {
      tl.to(svg, {
        opacity: 1,
        y: 0,
        duration: 0.4,
        ease: 'back.out(1.7)'
      });
    }
    if (i > 0) {
      tl.to(lineItemsInner, {
        yPercent: 0,
        opacity: 1,
        duration: 1,
        ease: 'power4.out',
        stagger: 0.15,

      });
      tl.to(lineItemsInner, {
        color: endColor,
        duration: 0.5,
        stagger: 0.2,
      }, "<")
      if (buttonGroup) {
        tl.to(buttonGroup, {
          opacity: 1,
          y: 0,
          duration: 1,
          ease: 'power3.out'
        }, '-=0.5');
      }
    }

    if (fansSansTypography) {
      console.log('FAN SANS TYPOGRAPHY')
      console.log(fansSansTypography)
      tl.to(fansSansTypography, {
        opacity: 1
      })
      tl.add(animateFanSansType(fansSansTypography));
      // tl.call(() => {
      //   // Once the text block finishing animating in/out...
      //   let typedTl = animateFanSansType(); // returns a normal timeline
      //   typedTl.play();
      // }, null, ">");

    }

    // Animate the special SVG if needed
    if (fastSVGElement && hasSVGAnimation) {
      const paths = fastSVGElement.querySelectorAll("path");

      // Set initial states for the paths
      gsap.set(paths, { fill: "#e10600" }); // starts red
      gsap.set(fastSVGElement, { opacity: 0, scale: 0.8 });

      // Animate the SVG in
      tl.to(fastSVGElement, {
        opacity: 1,
        scale: 1,
        duration: 1,
        ease: "power4.out"
      }, "+=0.5");
      // â†‘ "+=0.5" = wait 0.5s *after* previous step

      // Transition fill from red to black (runs at same time)
      tl.to(paths, {
        fill: "black",
        duration: 1,
        ease: "power2.inOut"
      }, "<");

      // (Optional) hold on screen a bit:
      tl.to(text, { duration: 1.0 }); // or .to({}, { duration: 1 })

      // Animate out to red & scale down
      tl.to(paths, {
        fill: "#e10600",
        duration: 0.5,
        ease: "power2.in"
      });
      tl.to(fastSVGElement, {
        opacity: 0,
        scale: 0.8,
        duration: 0.5,
        ease: "power2.in"
      }, "<");
    }

    // Hold the text for a bit
    tl.to(text, { duration: 1.2 });

    if (i !== 0) {
      tl.to(lineItemsInner, {
        yPercent: 0,
        opacity: 1,
        duration: 1,
        ease: 'power4.out',
        stagger: 0.15
      });
      if (buttonGroup) {
        tl.to(buttonGroup, {
          opacity: 1,
          y: 0,
          duration: 0.5,
          ease: 'power3.out'
        }, '-=0.5');
      }
    }

    // **Animate OUT** except for the last item
    if (i !== textRevealContents.length - 1) {
      tl.to(lineItemsInner, {
        yPercent: 100,
        duration: 0.8,
        opacity: 0,
        ease: 'power3.inOut',
        stagger: 0.1
      });
    }
    if (fastSVGElement && hasSVGAnimation) {
      tl.to(fastSVGElement, {
        opacity: 0,
        scale: 0.8,
        duration: 0.3,
        ease: 'power2.in'
      }, '<');
    }

    // Fade out button & normal SVG
    if (svg) {
      tl.to(svg, {
        opacity: 0,
        y: 20,
        duration: 0.3,
        ease: 'power2.in'
      }, '-=0.2');
    }
    if (buttonGroup) {
      tl.to(buttonGroup, {
        opacity: 0,
        y: 20,
        duration: 0.3,
        ease: 'back.out(1.7)'
      }, '-=0.2');
    }

    if (fansSansTypography) {
      console.log(fansSansTypography)
      tl.to(fansSansTypography, {
        opacity: 0
      })

    }

    revealMasterTl.add(tl);
  });

  const totalDuration = revealMasterTl.duration();
  if (isPageHeader && logoVideo && flagVideo) {
    revealMasterTl.to(logoVideo, {
      // yPercent: -30,
      opacity: 0,
      ease: "linear",
      duration: revealMasterTl.duration() * 0.15
    }, revealMasterTl.duration() * 0.1); // starts halfway through mastertl
    // revealMasterTl.to(flagVideo, {
    //   opacity: 0,
    //   duration: 1.5,
    //   ease: "power2.out"
    // }, `>${1.5}`);
    // better
    // revealMasterTl.to(logoVideo, {
    //   yPercent: -50,
    //   ease: "power4.out",
    //   border: "2px solid red",
    //   duration: revealMasterTl.duration() * 0.5
    // }, revealMasterTl.duration() * 0.5);
    // revealMasterTl.to(flagVideo, {
    //   opacity: 0,
    //   duration: 1.5,
    //   ease: "power2.out"
    // }, `>${1.5}`);
    // end better
    // revealMasterTl.to(logoVideo, {
    //   delay: 2,
    //   border: "2px solid red",
    //   // opacity: 0,
    //   yPercent: -20,
    //   ease: "power4.out",
    //   duration: revealMasterTl.duration()
    // }, );
    // Add this at 0, but stretch across full timeline
    // revealMasterTl.to([logoVideo, flagVideo], {
    //   delay: 2,
    //   // opacity: 0,
    //   y: -100,
    //   ease: "power4.out",
    //   duration: revealMasterTl.duration()
    // }, 0);

    // revealMasterTl.to([logoVideo, flagVideo], {
    //   y: -100,
    //   ease: "power4.inOut",
    //   duration: 1.5
    // }, `>${totalDuration - 1.5}`);
    // revealMasterTl.to(logoVideo, {
    //   border: "1px solid red",
    //   y: -100,
    //   ease: "power4.inOut",
    //   duration: 1.5
    // }, `>${totalDuration - 1.5}`);
  }
}

let headerRevealContent = document.querySelector('.section-header .text-reveal-wrapper')
revealText(headerRevealContent, true);
// revealHeaderText(headerRevealContent)

// function revealText(textRevealWrapper, textRevealContents) {

//   const revealMasterTl = gsap.timeline({
//     scrollTrigger: {
//       trigger: textRevealWrapper,
//       start: 'top top',
//       end: () => `+=${textRevealContents.length * 400}`,
//       pin: true,
//       scrub: 1,
//       // KEY: Reverses on scroll up
//       toggleActions: 'play none none reverse',
//     }
//   });

//   textRevealContents.forEach((text, i) => {
//     const lineItemsInner = text.querySelectorAll('.line-item__inner');
//     const svg = text.querySelector('.text-reveal-svg');
//     const buttonGroup = text.querySelector('.line-reveal-btn');
//     const hasSVGAnimation = text.hasAttribute('data-animate-svg');
//     const fastSVGElement = document.querySelector('.fast-svg');

//     const endColor = textRevealWrapper.getAttribute('data-end-color') || '#ffffff';

//     console.log(lineItemsInner)

//     // ******************************************
//     // 2) Universal initial states (for every item, including i===0)
//     //    => ALL blocks start red (#E10600)
//     // ******************************************
//     gsap.set(lineItemsInner, {
//       yPercent: 100,
//       opacity: 0,
//       color: "#E10600" // <--- each word starts red
//     });
//     if (svg) gsap.set(svg, { opacity: 0, y: 20 });
//     if (fastSVGElement) gsap.set(fastSVGElement, { opacity: 0, scale: 0.8 });

//     // if (buttonGroup) gsap.set(buttonGroup, { opacity: 0, y: 20 });
//     // (If you want the button group also hidden for i===0, re-uncomment above)

//     const tl = gsap.timeline();

//     if (i === 0) {
//       // lines in
//       tl.to(lineItemsInner, {
//         yPercent: 0,
//         opacity: 1,
//         duration: 1,
//         stagger: 0.15,
//         color: endColor,
//         ease: "power4.out"
//       });
//       // button in
//       if (buttonGroup) {
//         tl.to(buttonGroup, {
//           y: 0,
//           opacity: 1,
//           duration: 0.5,
//           ease: "power3.out"
//         }, "-=0.5");
//       }
//     }

//     // **Animate IN** for each text block
//     if (svg) {
//       tl.to(svg, {
//         opacity: 1,
//         y: 0,
//         duration: 0.4,
//         ease: 'back.out(1.7)'
//       });
//     }
//     if (i > 0) {
//       tl.to(lineItemsInner, {
//         yPercent: 0,
//         opacity: 1,
//         duration: 1,
//         ease: 'power4.out',
//         stagger: 0.15,

//       });
//       tl.to(lineItemsInner, {
//         color: endColor,
//         duration: .5,
//         stagger: 0.15,
//       }, "<")
//       if (buttonGroup) {
//         tl.to(buttonGroup, {
//           opacity: 1,
//           y: 0,
//           duration: 1,
//           ease: 'power3.out'
//         }, '-=0.5');
//       }
//     }

//     // Animate the special SVG if needed
//     if (fastSVGElement && hasSVGAnimation) {
//       const paths = fastSVGElement.querySelectorAll("path");

//       // Set initial states for the paths
//       gsap.set(paths, { fill: "#e10600" }); // starts red
//       gsap.set(fastSVGElement, { opacity: 0, scale: 0.8 });

//       // Animate the SVG in
//       tl.to(fastSVGElement, {
//         opacity: 1,
//         scale: 1,
//         duration: 1,
//         ease: "power4.out"
//       }, "+=0.5");
//       // â†‘ "+=0.5" = wait 0.5s *after* previous step

//       // Transition fill from red to black (runs at same time)
//       tl.to(paths, {
//         fill: "black",
//         duration: 1,
//         ease: "power2.inOut"
//       }, "<");

//       // (Optional) hold on screen a bit:
//       tl.to(text, { duration: 1.0 }); // or .to({}, { duration: 1 })

//       // Animate out to red & scale down
//       tl.to(paths, {
//         fill: "#e10600",
//         duration: 0.5,
//         ease: "power2.in"
//       });
//       tl.to(fastSVGElement, {
//         opacity: 0,
//         scale: 0.8,
//         duration: 0.5,
//         ease: "power2.in"
//       }, "<");
//     }

//     // Hold the text for a bit
//     tl.to(text, { duration: 1.2 });

//     if (i !== 0) {
//       tl.to(lineItemsInner, {
//         yPercent: 0,
//         opacity: 1,
//         duration: 1,
//         ease: 'power4.out',
//         stagger: 0.15
//       });
//       if (buttonGroup) {
//         tl.to(buttonGroup, {
//           opacity: 1,
//           y: 0,
//           duration: 0.5,
//           ease: 'power3.out'
//         }, '-=0.5');
//       }
//     }

//     // **Animate OUT** except for the last item
//     if (i !== textRevealContents.length - 1) {
//       tl.to(lineItemsInner, {
//         yPercent: 100,
//         duration: 0.8,
//         opacity: 0,
//         ease: 'power3.inOut',
//         stagger: 0.1
//       });
//     }
//     if (fastSVGElement && hasSVGAnimation) {
//       tl.to(fastSVGElement, {
//         opacity: 0,
//         scale: 0.8,
//         duration: 0.3,
//         ease: 'power2.in'
//       }, '<');
//     }

//     // Fade out button & normal SVG
//     if (svg) {
//       tl.to(svg, {
//         opacity: 0,
//         y: 20,
//         duration: 0.3,
//         ease: 'power2.in'
//       }, '-=0.2');
//     }
//     if (buttonGroup) {
//       tl.to(buttonGroup, {
//         opacity: 0,
//         y: 20,
//         duration: 0.3,
//         ease: 'back.out(1.7)'
//       }, '-=0.2');
//     }

//     revealMasterTl.add(tl);
//   });
// }

// function revealText(textRevealWrapper, textRevealContents) {
//   let direction = 1;
//   let progress = 0;
//   const revealMasterTl = gsap.timeline({
//     scrollTrigger: {
//       trigger: textRevealWrapper,
//       start: 'top top',
//       end: () => `+=${textRevealContents.length * 400}`,
//       pin: true,
//       scrub: 1,
//       // KEY: Reverses on scroll up
//       toggleActions: 'play none none reverse',
//       onEnter: () => {
//         overwrite: true,
//         loadFirstEl();
//       },
//       onUpdate: self => {
//         progress = self.progress;
//         // console.log(`progress ${progress}`)
//         if (self.direction !== self.prevDirection) {
//           console.log("toggled!");
//           self.prevDirection = self.direction;
//           direction = self.direction;
//           // console.log(direction)

//         }
//       }
//     }
//   });

//   function loadFirstEl() {
//     let tl = gsap.timeline()
//     let firstContents = textRevealContents[0];
//     let text = firstContents.querySelectorAll('.line-item__inner');
//     let firstBtn = firstContents.querySelector('.line-reveal-btn')
//     // console.log
//     tl.to(text, {
//       border: "2px solid red",
//       yPercent: 0,
//       opacity: 1,
//       duration: 1,
//       stagger: 0.15,
//       color: "white",
//       ease: "power4.out"
//     })
//     if (firstBtn) {
//       tl.fromTo(firstBtn, {
//         yPercent: 100,
//         opacity: 0
//       }, {
//         border: "2px solid red",
//         yPercent: 0,
//         opacity: 1,
//         duration: 1,
//         stagger: 0.15,
//         color: "white",
//         ease: "power4.out"
//       })
//     }
//   }

//   textRevealContents.forEach((text, i) => {
//     const lineItemsInner = text.querySelectorAll('.line-item__inner');
//     const svg = text.querySelector('.text-reveal-svg');
//     const buttonGroup = text.querySelector('.line-reveal-btn');
//     const hasSVGAnimation = text.hasAttribute('data-animate-svg');
//     const fastSVGElement = document.querySelector('.fast-svg');
//     const bigTextAnimation = textRevealContents[i].querySelector('.banner13_animation')
//     const typographyFans = textRevealContents[i].querySelector('.typography-fans-svg');

//     const endColor = textRevealWrapper.getAttribute('data-end-color') || '#ffffff';

//     // ******************************************
//     // 2) Universal initial states (for every item, including i===0)
//     //    => ALL blocks start red (#E10600)
//     // ******************************************
//     gsap.set(lineItemsInner, {
//       yPercent: 100,
//       opacity: 0,
//       color: "#E10600" // <--- each word starts red
//     });
//     if (svg) gsap.set(svg, { opacity: 0, y: 20 });
//     if (fastSVGElement) gsap.set(fastSVGElement, { opacity: 0, scale: 0.8 });

//     // if (buttonGroup) gsap.set(buttonGroup, { opacity: 0, y: 20 });
//     // (If you want the button group also hidden for i===0, re-uncomment above)

//     const tl = gsap.timeline();

//     tl.add(() => {
//       console.log(`Animating index ${i}, Current Direction: ${direction}`);

//       if (direction === -1) {
//         console.log(`Scrolling UP at index ${i}`);
//         // Example: Reverse animation when scrolling up
//       } else {
//         console.log(`Scrolling DOWN at index ${i}`);
//       }

//       if (direction === -1 && i === 1) {
//         console.log("At index 0, preventing fade-out on scroll up");
//         return; // Stops this block from executing further
//       }
//     });

//     if (typographyFans) {
//       let typographyFansSVG = typographyFans.querySelector("svg");

//       // Instead of a set + a .to(),
//       // do a fromTo right in the timeline:
//       tl.fromTo(
//         typographyFansSVG,
//         {
//           // START STATE:
//           // clipPath: "inset(0 100% 0 0)", // hide from the right
//           xPercent: 150, // push it offscreen to the right
//           skewX: 10, // tilt
//           transformOrigin: "100% 50%", // pivot around right edge
//           // opacity: 0
//         },
//         {
//           // END STATE:
//           xPercent: 0,
//           clipPath: "inset(0 0 0 0)", // fully visible
//           x: 0, // slide back to normal
//           skewX: 0, // remove tilt
//           duration: 4,
//           ease: "power4.out"
//         }
//       );
//     }

//     if (bigTextAnimation) {
//       let bigTextTop = bigTextAnimation.querySelector('.banner13_heading-top')
//       let bigTextBtm = bigTextAnimation.querySelector('.banner13_heading-bottom')
//       gsap.set(bigTextTop, {
//         opacity: 0,
//         xPercent: 25
//       })
//       gsap.set(bigTextBtm, {
//         opacity: 0,
//         xPercent: -25
//       })

//       tl.to(bigTextTop, {
//         opacity: 1,
//         xPercent: 15,
//         duration: 2,
//       })
//       tl.to(bigTextBtm, {
//         opacity: 1,
//         xPercent: -15,
//         duration: 2,
//       }, "<")

//       tl.to({}, { duration: 2 });

//       tl.to(bigTextTop, {
//         xPercent: 100, // send it back off-screen to the right
//         opacity: 0,
//         duration: 2,
//         ease: "power4.in"
//       })
//       tl.to(bigTextBtm, {
//         xPercent: -100, // send it off-screen to the left
//         opacity: 0,
//         duration: 2,
//         ease: "power4.in"
//       }, "<");
//     }

//     // **Animate IN** for each text block
//     if (svg) {
//       tl.to(svg, {
//         opacity: 1,
//         y: 0,
//         duration: 0.4,
//         ease: 'back.out(1.7)'
//       });
//     }
//     if (i > 0) {
//       tl.to(lineItemsInner, {
//         yPercent: 0,
//         opacity: 1,
//         duration: 1,
//         ease: 'power4.out',
//         stagger: 0.15,

//       });
//       tl.to(lineItemsInner, {
//         color: endColor,
//         duration: 0.5,
//         stagger: 0.2,
//       }, "<")
//       if (buttonGroup) {
//         tl.to(buttonGroup, {
//           opacity: 1,
//           y: 0,
//           duration: 1,
//           ease: 'power3.out'
//         }, '-=0.5');
//       }
//     }

//     // Animate the special SVG if needed
//     if (fastSVGElement && hasSVGAnimation) {
//       const paths = fastSVGElement.querySelectorAll("path");

//       // Set initial states for the paths
//       gsap.set(paths, { fill: "#e10600" }); // starts red
//       gsap.set(fastSVGElement, { opacity: 0, scale: 0.8 });

//       // Animate the SVG in
//       tl.to(fastSVGElement, {
//         opacity: 1,
//         scale: 1,
//         duration: 1,
//         ease: "power4.out"
//       }, "+=0.5");
//       // â†‘ "+=0.5" = wait 0.5s *after* previous step

//       // Transition fill from red to black (runs at same time)
//       tl.to(paths, {
//         fill: "black",
//         duration: 1,
//         ease: "power2.inOut"
//       }, "<");

//       // (Optional) hold on screen a bit:
//       tl.to(text, { duration: 1.0 }); // or .to({}, { duration: 1 })

//       // Animate out to red & scale down
//       tl.to(paths, {
//         fill: "#e10600",
//         duration: 0.5,
//         ease: "power2.in"
//       });
//       tl.to(fastSVGElement, {
//         opacity: 0,
//         scale: 0.8,
//         duration: 0.5,
//         ease: "power2.in"
//       }, "<");
//     }

//     // Hold the text for a bit
//     tl.to(text, { duration: 1.2 });

//     if (i !== textRevealContents.length - 1) {
//       tl.to(lineItemsInner, {
//         yPercent: 100,
//         duration: 0.8,
//         opacity: 0,
//         ease: 'power3.inOut',
//         stagger: 0.1
//       }).add(() => {
//         if (direction === -1 && i === 1) {
//           console.log(`Preventing fade-out at index ${i} because scrolling up`);
//           return;
//         }
//         console.log(`Fading out index ${i}`);
//       }, "-=0.2"); // ðŸ”¹ Add delay to prevent overlapping transitions
//     }

//     // // if (i !== 0) {
//     // tl.to(lineItemsInner, {
//     //   yPercent: 0,
//     //   opacity: 1,
//     //   duration: 1,
//     //   ease: 'power4.out',
//     //   stagger: 0.15
//     // });
//     // if (buttonGroup) {
//     //   tl.to(buttonGroup, {
//     //     opacity: 1,
//     //     y: 0,
//     //     duration: 0.5,
//     //     ease: 'power3.out'
//     //   }, '-=0.5');
//     // }
//     // // }

//     // // **Animate OUT** except for the last item
//     // if (i !== textRevealContents.length - 1) {
//     //   tl.to(lineItemsInner, {
//     //     yPercent: 100,
//     //     duration: 0.8,
//     //     opacity: 0,
//     //     ease: 'power3.inOut',
//     //     stagger: 0.1
//     //   });
//     // }
//     if (fastSVGElement && hasSVGAnimation) {
//       tl.to(fastSVGElement, {
//         opacity: 0,
//         scale: 0.8,
//         duration: 0.3,
//         ease: 'power2.in'
//       }, '<');
//     }

//     // Fade out button & normal SVG
//     if (svg) {
//       tl.to(svg, {
//         opacity: 0,
//         y: 20,
//         duration: 0.3,
//         ease: 'power2.in'
//       }, '-=0.2');
//     }
//     if (buttonGroup) {
//       tl.to(buttonGroup, {
//         opacity: 0,
//         y: 20,
//         duration: 0.3,
//         ease: 'back.out(1.7)'
//       }, '-=0.2');
//     }

//     revealMasterTl.add(tl);
//   });
// }

//closest
// function revealText(textRevealWrapper, textRevealContents) {
//   let direction = 1;
//   let progress = 0;
//   const revealMasterTl = gsap.timeline({
//     scrollTrigger: {
//       trigger: textRevealWrapper,
//       start: 'top top',
//       end: () => `+=${textRevealContents.length * 400}`,
//       pin: true,
//       scrub: 1,
//       // KEY: Reverses on scroll up
//       toggleActions: 'play none none reverse',
//       onEnter: () => {
//         revealMasterTl.pause();
//         loadFirstEl();

//       },
//       onUpdate: self => {
//         progress = self.progress;
//         console.log(`progress ${progress}`)
//         if (self.direction !== self.prevDirection) {
//           console.log("toggled!");
//           self.prevDirection = self.direction;
//           direction = self.direction;
//           console.log(direction)

//         }
//       }
//     }
//   });

//   function loadFirstEl() {
//     let tl = gsap.timeline({
//       onComplete: () => {
//         console.log("First animation complete. Resuming main timeline...");
//         revealMasterTl.play(); // âœ… Resume after animation finishes
//       }
//     })
//     let firstContents = textRevealContents[0];
//     let text = firstContents.querySelectorAll('.line-item__inner');
//     let firstBtn = firstContents.querySelector('.line-reveal-btn')
//     // console.log
//     tl.to(text, {
//       border: "2px solid red",
//       yPercent: 0,
//       opacity: 1,
//       duration: 1,
//       stagger: 0.15,
//       color: "white",
//       ease: "power4.out"
//     })
//     if (firstBtn) {
//       tl.fromTo(firstBtn, {
//         yPercent: 100,
//         opacity: 0
//       }, {
//         border: "2px solid red",
//         yPercent: 0,
//         opacity: 1,
//         duration: 1,
//         stagger: 0.15,
//         color: "white",
//         ease: "power4.out"
//       })
//     }
//   }

//   textRevealContents.forEach((text, i) => {
//     const lineItemsInner = text.querySelectorAll('.line-item__inner');
//     const svg = text.querySelector('.text-reveal-svg');
//     const buttonGroup = text.querySelector('.line-reveal-btn');
//     const hasSVGAnimation = text.hasAttribute('data-animate-svg');
//     const fastSVGElement = document.querySelector('.fast-svg');
//     const bigTextAnimation = textRevealContents[i].querySelector('.banner13_animation')
//     const typographyFans = textRevealContents[i].querySelector('.typography-fans-svg');

//     const endColor = textRevealWrapper.getAttribute('data-end-color') || '#ffffff';

//     // ******************************************
//     // 2) Universal initial states (for every item, including i===0)
//     //    => ALL blocks start red (#E10600)
//     // ******************************************
//     gsap.set(lineItemsInner, {
//       yPercent: 100,
//       opacity: 0,
//       color: "#E10600" // <--- each word starts red
//     });
//     if (svg) gsap.set(svg, { opacity: 0, y: 20 });
//     if (fastSVGElement) gsap.set(fastSVGElement, { opacity: 0, scale: 0.8 });

//     // if (buttonGroup) gsap.set(buttonGroup, { opacity: 0, y: 20 });
//     // (If you want the button group also hidden for i===0, re-uncomment above)

//     const tl = gsap.timeline();

//     //current
//     // if (i === 0) {
//     //   // lines in
//     //   tl.to(lineItemsInner, {
//     //     yPercent: 0,
//     //     opacity: 1,
//     //     duration: 1,
//     //     stagger: 0.15,
//     //     color: endColor,
//     //     ease: "power4.out"
//     //   });
//     //   // button in
//     //   if (buttonGroup) {
//     //     tl.to(buttonGroup, {
//     //       y: 0,
//     //       opacity: 1,
//     //       duration: 0.5,
//     //       ease: "power3.out"
//     //     }, "-=0.5");
//     //   }
//     // }

//     //nope
//     // if (i === 0) {
//     //   revealMasterTl.add(() => {
//     //     gsap.to(lineItemsInner, {
//     //       yPercent: 0,
//     //       opacity: 1,
//     //       duration: .51,
//     //       stagger: 0.15,
//     //       color: endColor,
//     //       ease: "power4.out"
//     //     })
//     //   }, 0)
//     //   console.log(revealMasterTl)

//     //   if (direction === -1) {
//     //     console.log(lineItemsInner)
//     //   }

//     //   // lines in
//     //   // tl.to(lineItemsInner, {
//     //   //   yPercent: 0,
//     //   //   opacity: 1,
//     //   //   duration: 1,
//     //   //   stagger: 0.15,
//     //   //   color: endColor,
//     //   //   ease: "power4.out"
//     //   // });
//     //   tl.to(lineItemsInner, {
//     //     color: endColor, // e.g., "#FFFFFF" or "#000000"
//     //     duration: 0.5,
//     //     stagger: 0.2,
//     //     ease: "power2.out"
//     //   }, ">0.2");
//     //   // button in
//     //   if (buttonGroup) {
//     //     tl.to(buttonGroup, {
//     //       y: 0,
//     //       opacity: 1,
//     //       duration: 0.5,
//     //       ease: "power3.out"
//     //     }, "-=0.5");
//     //   }
//     // }

//     if (typographyFans) {
//       let typographyFansSVG = typographyFans.querySelector("svg");

//       // Instead of a set + a .to(),
//       // do a fromTo right in the timeline:
//       tl.fromTo(
//         typographyFansSVG,
//         {
//           // START STATE:
//           // clipPath: "inset(0 100% 0 0)", // hide from the right
//           xPercent: 150, // push it offscreen to the right
//           skewX: 10, // tilt
//           transformOrigin: "100% 50%", // pivot around right edge
//           // opacity: 0
//         },
//         {
//           // END STATE:
//           xPercent: 0,
//           clipPath: "inset(0 0 0 0)", // fully visible
//           x: 0, // slide back to normal
//           skewX: 0, // remove tilt
//           duration: 4,
//           ease: "power4.out"
//         }
//       );
//     }

//     if (bigTextAnimation) {
//       let bigTextTop = bigTextAnimation.querySelector('.banner13_heading-top')
//       let bigTextBtm = bigTextAnimation.querySelector('.banner13_heading-bottom')
//       gsap.set(bigTextTop, {
//         opacity: 0,
//         xPercent: 25
//       })
//       gsap.set(bigTextBtm, {
//         opacity: 0,
//         xPercent: -25
//       })

//       tl.to(bigTextTop, {
//         opacity: 1,
//         xPercent: 15,
//         duration: 2,
//       })
//       tl.to(bigTextBtm, {
//         opacity: 1,
//         xPercent: -15,
//         duration: 2,
//       }, "<")

//       tl.to({}, { duration: 2 });

//       tl.to(bigTextTop, {
//         xPercent: 100, // send it back off-screen to the right
//         opacity: 0,
//         duration: 2,
//         ease: "power4.in"
//       })
//       tl.to(bigTextBtm, {
//         xPercent: -100, // send it off-screen to the left
//         opacity: 0,
//         duration: 2,
//         ease: "power4.in"
//       }, "<");
//     }

//     // **Animate IN** for each text block
//     if (svg) {
//       tl.to(svg, {
//         opacity: 1,
//         y: 0,
//         duration: 0.4,
//         ease: 'back.out(1.7)'
//       });
//     }
//     if (i > 0) {
//       tl.to(lineItemsInner, {
//         yPercent: 0,
//         opacity: 1,
//         duration: 1,
//         ease: 'power4.out',
//         stagger: 0.15,

//       });
//       tl.to(lineItemsInner, {
//         color: endColor,
//         duration: 0.5,
//         stagger: 0.2,
//       }, "<")
//       if (buttonGroup) {
//         tl.to(buttonGroup, {
//           opacity: 1,
//           y: 0,
//           duration: 1,
//           ease: 'power3.out'
//         }, '-=0.5');
//       }
//     }

//     // Animate the special SVG if needed
//     if (fastSVGElement && hasSVGAnimation) {
//       const paths = fastSVGElement.querySelectorAll("path");

//       // Set initial states for the paths
//       gsap.set(paths, { fill: "#e10600" }); // starts red
//       gsap.set(fastSVGElement, { opacity: 0, scale: 0.8 });

//       // Animate the SVG in
//       tl.to(fastSVGElement, {
//         opacity: 1,
//         scale: 1,
//         duration: 1,
//         ease: "power4.out"
//       }, "+=0.5");
//       // â†‘ "+=0.5" = wait 0.5s *after* previous step

//       // Transition fill from red to black (runs at same time)
//       tl.to(paths, {
//         fill: "black",
//         duration: 1,
//         ease: "power2.inOut"
//       }, "<");

//       // (Optional) hold on screen a bit:
//       tl.to(text, { duration: 1.0 }); // or .to({}, { duration: 1 })

//       // Animate out to red & scale down
//       tl.to(paths, {
//         fill: "#e10600",
//         duration: 0.5,
//         ease: "power2.in"
//       });
//       tl.to(fastSVGElement, {
//         opacity: 0,
//         scale: 0.8,
//         duration: 0.5,
//         ease: "power2.in"
//       }, "<");
//     }

//     // Hold the text for a bit
//     tl.to(text, { duration: 1.2 });

//     if (i !== 0) {
//       tl.to(lineItemsInner, {
//         yPercent: 0,
//         opacity: 1,
//         duration: 1,
//         ease: 'power4.out',
//         stagger: 0.15
//       });
//       if (buttonGroup) {
//         tl.to(buttonGroup, {
//           opacity: 1,
//           y: 0,
//           duration: 0.5,
//           ease: 'power3.out'
//         }, '-=0.5');
//       }
//     }

//     // **Animate OUT** except for the last item
//     if (i !== textRevealContents.length - 1) {
//       tl.to(lineItemsInner, {
//         yPercent: 100,
//         duration: 0.8,
//         opacity: 0,
//         ease: 'power3.inOut',
//         stagger: 0.1
//       });
//     }
//     if (fastSVGElement && hasSVGAnimation) {
//       tl.to(fastSVGElement, {
//         opacity: 0,
//         scale: 0.8,
//         duration: 0.3,
//         ease: 'power2.in'
//       }, '<');
//     }

//     // Fade out button & normal SVG
//     if (svg) {
//       tl.to(svg, {
//         opacity: 0,
//         y: 20,
//         duration: 0.3,
//         ease: 'power2.in'
//       }, '-=0.2');
//     }
//     if (buttonGroup) {
//       tl.to(buttonGroup, {
//         opacity: 0,
//         y: 20,
//         duration: 0.3,
//         ease: 'back.out(1.7)'
//       }, '-=0.2');
//     }

//     revealMasterTl.add(tl);
//   });
// }

function revealFSVideo() {
  const fullSizeVideoRevealSection = document.querySelector('.video-reveal-section');
  const video = document.querySelector('.full-size-video');
  const lightboxButtons = fullSizeVideoRevealSection.querySelector('.lightbox-button-group');

  // Initial states: Slightly smaller scale, opacity at full, clipped top/bottom
  gsap.set(video, {
    scale: 0.85,
    opacity: 1,
    y: 50,
    clipPath: "inset(20% 0 20% 0)" // Clips top and bottom, but keeps width full
  });

  gsap.set(lightboxButtons, { opacity: 0, yPercent: 20 });

  const tl = gsap.timeline({
    scrollTrigger: {
      trigger: fullSizeVideoRevealSection,
      start: "top center",
      end: "center center",
      scrub: 1,
    }
  });

  // 1) Reveal video by unclipping, scaling up, and moving up
  tl.to(video, {
    scale: 1,
    opacity: 1,
    y: 0,
    clipPath: "inset(0% 0% 0% 0%)", // Fully reveals the video
    duration: 1.2,
    ease: "power4.out"
  });

  // 2) Stagger in the buttons AFTER the video is mostly on screen
  tl.fromTo(lightboxButtons, { opacity: 0, yPercent: 20 }, {
      opacity: 1,
      yPercent: 0,
      duration: 0.6,
      ease: "back.out(1.7)"
    },
    ">0.3" // waits 0.3s after the video finishes
  );
}

revealFSVideo();

function kineticText() {
  let kineticSections = document.querySelectorAll('.kinetic-section');

  kineticSections.forEach((section) => {

    let tl = gsap.timeline({
      scrollTrigger: {
        trigger: section,
        start: "top top",
        end: "bottom center",
        // scrub: false,
        // pin: section,
        toggleActions: "play none none reset",
        // onLeave: ({ progress, direction, isActive }) => {

        //   // allDups.remove()
        //   console.log(allDups)
        //   console.log(progress, direction,
        //     isActive)
        // }
      }
    });

    let words = section.querySelectorAll('.word');
    let svg = section.querySelector(".kinetic-svg");
    let svgPaths = svg.querySelectorAll("path");

    // 1) Initial States
    gsap.set(svg, {
      // Slightly smaller so we can snap up at the end
      transform: "scale(0.9)",
    });

    gsap.set(words, {
      // Make sure theyâ€™re invisible and moved downward
      opacity: 0,
      y: 30,
      transformOrigin: "center"
    });

    gsap.set(svgPaths, {
      // Red stroke/fill so we can see the color change
      stroke: "#E10600",
      fill: "#E10600",
      strokeWidth: "3px"
    });

    // 2) Timeline animation
    // (A) Fade/move words into place
    tl.to(words, {
      opacity: 1,
      y: 0,
      duration: 0.5,
      ease: "power4.out",
      stagger: 0.12
    });

    tl.to(svgPaths, {
      stroke: "#fff",
      fill: "#fff",
      duration: 1.0,
      ease: "power2.out"
    }, "<");
    // If you want a noticeable gap before the color fades, try: }, ">0.2");

    // (C) Snap the SVG up to scale=1
    tl.to(svg, {
      transform: "scale(1)",
      duration: 0.1,
      ease: "power1.out",

    });

    // 3) Clones!
    // tl.add(() => {
    //   let container = svg.parentNode;
    //   let svgBox = svg.getBoundingClientRect();
    //   let originalTransform = getComputedStyle(svg).transform;

    //   for (let i = 1; i <= 5; i++) {
    //     let cloneTop = svg.cloneNode(true);
    //     let cloneBottom = svg.cloneNode(true);

    //     cloneTop.classList.add("duplicate-top");
    //     cloneBottom.classList.add("duplicate-bottom");

    //     container.appendChild(cloneTop);
    //     container.appendChild(cloneBottom);

    //     gsap.set([cloneTop, cloneBottom], {
    //       position: "absolute",
    //       top: 0,
    //       left: '0',
    //       width: svgBox.width,
    //       height: svgBox.height,
    //       opacity: 1,
    //       scale: 1,
    //       pointerEvents: "none",
    //       transform: originalTransform
    //     });

    //     // Make cloned words invisible fill
    //     gsap.set(cloneTop.querySelectorAll("path"), { fill: "none" });
    //     gsap.set(cloneBottom.querySelectorAll("path"), { fill: "none" });

    //     // gsap.pause()

    //     // Move clones up & down offscreen
    //     gsap.to(cloneTop, {
    //       y: -(80 * i),
    //       opacity: 0,
    //       duration: 1.5,
    //       ease: "power2.in"
    //     });
    //     gsap.to(cloneBottom, {
    //       y: 80 * i,
    //       opacity: 0,
    //       duration: 1.5,
    //       ease: "power2.in",
    //       onComplete: () => {
    //         console.log('removing dups')
    //         let allDups = [...document.querySelectorAll(
    //             '.kinetic-svg.duplicate-bottom'),
    //           ...document.querySelectorAll('.kinetic-svg.duplicate-top')
    //         ];
    //         if (allDups.length) {
    //           allDups.forEach((dup, i) => {
    //             dup.remove()
    //           })
    //         }
    //       }
    //     });
    //   }
    // }, "+=0.4");
  });
}

kineticText();

// function testHeader() {
//   let section = document.querySelector("#section-header-test");
//   let header = section.querySelector('.section-header-text')
//   let number = section.querySelector('#section-header-number-small')
//   console.log(header)
//   let tl = gsap.timeline({
//     scrollTrigger: {
//       trigger: section,
//       start: "top 80%", // Fade in before pinning starts
//       end: "bottom 110%",
//       scrub: 3,
//       // markers: true
//       // toggleActions: "play none none reset",

//     }
//   })

//   gsap.set(header, {
//     scale: 2
//   })

//   tl.fromTo(header, {
//     xPercent: 100,

//   }, {
//     xPercent: 0,

//   })
//   tl.to(header, {
//     scale: 1
//   })
//   tl.from(number, {
//     yPercent: 500,
//     duration: 2
//   }, "")
// }

// testHeader()

const sectionHeaders = document.querySelectorAll('.section-header_numbered');
sectionHeaders.forEach((section, i) => {
  let header = section.querySelector('.section-header_headline')
  let number = section.querySelector('.section-header_number')

  gsap.set(header, {
    color: "#E10600",
  });
  gsap.set([header, number], {
    opacity: 0,
    yPercent: 30
  });

  let tl = gsap.timeline({
    scrollTrigger: {
      trigger: section,
      start: "top 40%",
      end: "bottom center",
      // scrub: 1,
      // markers: true,
      toggleActions: "play none none reset"

    }
  });

  tl.to([header, number], {
    opacity: 1,
    yPercent: 0,
    duration: 0.75,
    ease: "power4.out",
    stagger: 0.12
  });
  tl.to(header, {
    color: "#FFFFFF",
  }, "<");

  let markerTl = gsap.timeline({
    scrollTrigger: {
      trigger: header,
      start: "top top",
      end: "bottom top",
      // scrub: 1,
      // markers: true,
      toggleActions: "play none none reset"

    }
  })
  // markerTl.to()
})

// GSDevTools.create({ animation: kineticText });

// dot Animate
function dotAnimate() {
  let dotAnimation = gsap.timeline({
    scrollTrigger: {
      // trigger: ".dot-reveal-section",
      trigger: ".dot-reveal-section .text-color-black",
      start: "top 40%",
      // end: "top 20%",
      end: "+=300",
      toggleActions: "play none none reverse",
      // pin: ".dot-wrapper",
      // pinSpacing: false

    }
  });
  dotAnimation.to('.dot-wrapper', {
    // clipPath: "circle(120% at center)",
    clipPath: "circle(120% at 50% 75%)",
    duration: 1,
    ease: "power2.out"

  })
}

dotAnimate();

let brandIdentContent = document.querySelector(".section-brand-identity .text-reveal-wrapper");

revealText(brandIdentContent)

function scrollAccordion(titles, defs, wrapper) {

  let currentIndex = 0;
  const time = .8;

  // 1) Hide initially
  gsap.set(wrapper, { autoAlpha: 0 });

  // 2) "Pre-pin" fade in from 0 -> 1
  //    - short range so it's done before we reach top top
  //    - or just do onEnter with no `end` if you want an immediate fade
  ScrollTrigger.create({
    trigger: wrapper,
    start: "top 80%",
    end: "top 70%", // short distance
    onEnter: () => {
      gsap.to(wrapper, {
        autoAlpha: 1,
        duration: 0.8,
        ease: "power2.out"
      });
    },
    // just fade once, no reversing
    toggleActions: "play none none none",
  });

  activateTitle(0);
  moveDefinition(0);

  function setUniformHeights() {
    requestAnimationFrame(() => {
      let maxHeight = Math.ceil(
        Math.max(...defs.map((def) => def.getBoundingClientRect().height))
      );

      // Apply the max height to all definitions
      defs.forEach((def) => (def.style.height = maxHeight + "px"));

      // Set the wrapper height to fit one definition at a time
      wrapper.querySelector(".definition-wrapper").style.height =
        maxHeight + "px";
    });
  }
  setUniformHeights();

  window.addEventListener("resize", () => {
    setUniformHeights(); // Recalculate
    moveDefinition(currentIndex);
  });

  ScrollTrigger.create({
    trigger: wrapper,
    pin: true,
    start: "top top",
    scrub: 1,
    // scroller: smoother ? smoother.wrapper() : undefined,
    // end: "+=2000",
    end: () => `+=${(titles.length - 1) * 500}`,
    // anticipatePin: true,
    onUpdate: (self) => {
      let newIndex = Math.floor(self.progress * titles.length);
      newIndex = Math.min(newIndex, titles.length - 1);

      if (newIndex !== currentIndex) {
        currentIndex = newIndex;
        activateTitle(currentIndex);
        moveDefinition(currentIndex);
      }
    }
  });

  function activateTitle(index) {
    titles.forEach((t) => t.classList.remove("active"));

    let activeTitle = titles[index];
    activeTitle.classList.add("active");

    gsap.fromTo(
      activeTitle,
      {
        autoAlpha: 0,
        x: 50
      },
      {
        autoAlpha: 1,
        x: 0,
        duration: time,
        ease: "power4.out"
      }
    );
  }

  function moveDefinition(index) {
    let maxHeight = Math.max(...defs.map((def) => def.scrollHeight));

    gsap.to(defs, {
      y: (i) => -(i - index) * maxHeight,
      autoAlpha: (i) => (i === index ? 1 : 0),
      duration: time,
      ease: "power4.out"
    });
  }
}

let brandAccordionWrapper = document.querySelector(
  '.section-brand-design .scroll-accordion-wrapper')
let brandTitles = gsap.utils.toArray(
  ".section-brand-design .scroll-accordion-wrapper .accordion-title");
let brandDefs = gsap.utils.toArray(".section-brand-design .scroll-accordion-wrapper .definition");

scrollAccordion(brandTitles, brandDefs, brandAccordionWrapper)

let logoRevealContent = document.querySelector('.section-logo .text-reveal-wrapper');

revealText(logoRevealContent)

function setTextFadeMinHeight(wrapper, textBlocks) {
  // console.log(`wrapper`)
  // console.log(wrapper)
  // console.log(`textBlocks`)
  // console.log(textBlocks)
  // const wrapper = document.querySelector(".lottie-text-fade");
  // const headings = wrapper.querySelectorAll("h1");

  let tallest = 0;
  textBlocks.forEach(h => {
    // Temporarily make visible to measure hidden elements
    const prevStyle = h.style.display;
    h.style.display = "block";
    h.style.position = "absolute";
    h.style.opacity = "0";

    const height = h.offsetHeight;
    // console.log(h)
    // console.log(`height: ${height}`)
    if (height > tallest) tallest = height;

    // Reset style
    h.style.display = prevStyle;
    h.style.position = "";
    h.style.opacity = "";
  });

  // âœ… Apply tallest height to container
  wrapper.style.minHeight = tallest + "px";
}

function playFanSansLottie() {
  let section = document.querySelector('.fan-sans-lottie-section');
  const textBlocks = section.querySelectorAll(".lottie-text-fade .heading-style-h2");
  let currentFrame = 0;
  let lastActiveIndex = -1;
  const wrapper = section.querySelector(".lottie-text-fade");
  let blocks = section.querySelectorAll('.background-block');
  let accessibleFrame = section.querySelector('.accessible-frame').dataset.frame;
  gsap.set(blocks, {
    opacity: 0
  })

  setTextFadeMinHeight(wrapper, textBlocks);

  let lottieAnimation = lottie.loadAnimation({
    container: document.querySelector(".lottie-element"),
    renderer: "svg",
    loop: false,
    autoplay: false,
    path: "https://cdn.prod.website-files.com/67b4c8583d604cb6c2fc9a62/67e40ae7093e8d53e37e4f3a_FanSans_Animation3.json"
  });

  window.addEventListener("resize", () => {
    setTextFadeMinHeight(wrapper, textBlocks)
  });

  // âœ… â¬‡ï¸ Scrub Lottie with scroll after it's loaded
  lottieAnimation.addEventListener("DOMLoaded", () => {
    const totalFrames = lottieAnimation.totalFrames;

    gsap.to(lottieAnimation, {
      frame: totalFrames - 1,
      ease: "none",
      scrollTrigger: {
        trigger: section,
        start: "top top",
        end: "+=2000", // control scroll length
        pin: true,
        scrub: true,
      },
      onUpdate: () => {
        lottieAnimation.goToAndStop(lottieAnimation.frame, true);
      }
    });
  });

  // âœ… Trigger text changes based on frame
  const frameTriggers = Array.from(textBlocks).map((el, index) => ({
    frame: parseInt(el.dataset.frame, 10),
    el,
    index
  }));

  let currentTextTween = null; // ðŸ§  track active animation

  lottieAnimation.addEventListener("enterFrame", (e) => {
    currentFrame = e.currentTime;

    if (currentFrame < parseInt(accessibleFrame)) {
      gsap.to(blocks, {
        opacity: 0,
        // y: 20,
        duration: 0.15,
        ease: "power2.inOut"
      });
    }

    const active = frameTriggers
      .filter(trigger => currentFrame >= trigger.frame)
      .sort((a, b) => b.frame - a.frame)[0];

    if (!active || active.index === lastActiveIndex) return;

    lastActiveIndex = active.index;

    if (currentTextTween) currentTextTween.kill();

    textBlocks.forEach(el => {
      gsap.set(el, {
        opacity: 0,
        // y: 20

      });
    });

    // currentTextTween = gsap.to(active.el, {
    //   opacity: 1,
    //   y: 0,
    //   duration: 0.5,
    //   ease: "power2.out"
    // });

    // Animate current text
    currentTextTween = gsap.to(active.el, {
      opacity: 1,
      y: 0,
      duration: 0.5,
      ease: "power2.out"
    });

    // âœ… Trigger background-block animation when we hit the accessible frame
    if (active.el.classList.contains("accessible-frame")) {
      gsap.fromTo(blocks, {
        width: "0%",
        transformOrigin: "center center"
      }, {
        opacity: 1,
        width: "100%",
        duration: 1,
        ease: "power4.out",
      });
    }
  });
}
playFanSansLottie()

const lottieWrapper = document.querySelector(".fan-sans-lottie-section .lottie-text-fade");
const lottieTextBlocks = document.querySelectorAll('.fan-sans-lottie-section .heading-style-h2')
setTextFadeMinHeight(lottieWrapper, lottieTextBlocks);

function sectionLogos(logoSection) {
  // let logoSection = document.querySelector('.section_logo1');
  let logoWraps = [...logoSection.querySelectorAll('.logo-content_wrap')];

  let tl = gsap.timeline({
    scrollTrigger: {
      trigger: logoSection,
      start: "top top",
      end: "+=5000",
      pin: true,
      scrub: 2,
      anticipatePin: 1,
    }
  });

  logoWraps.forEach((wrap, i) => {

    // Grab the .heading-style-h1 elements
    let textHeaders = [...wrap.querySelectorAll('.heading-style-h1')];
    let logoLists = [...wrap.querySelectorAll('.logo-list_inner')];

    // FORMER CODE:
    // gsap.set(textHeaders, { yPercent: 100, opacity: 0 });

    // Instead: for each heading, split into words & animate them in
    textHeaders.forEach((header, hIndex) => {
      // 1) Split into .line-item__inner spans
      let words = splitTextIntoWords(header, "line-item", "line-item__inner");

      // 2) Set initial states: below, invisible, red
      gsap.set(words, {
        opacity: 0,
        yPercent: 100,
        color: "#E10600"
      });

      // 3) Animate the words upward & fade in
      tl.to(words, {
        opacity: 1,
        yPercent: 0,
        duration: 1,
        ease: "power4.out",
        stagger: 0.1
      }, `+=${hIndex * 0.5}`);

      // 4) Simultaneously shift color from red to black
      tl.to(words, {
        color: "#000",
        ease: "power2.out",

        duration: 1,
        stagger: 0.15,
        // color: "",
      }, "<"); // "<" = at the same time as the fade-in
    });

    // Animate the logo marquee
    if (logoLists.length > 0) {
      let logoTl = gsap.timeline();

      logoLists.forEach((logoList, i) => {
        let parentWidth = logoList.parentElement.offsetWidth;
        let innerWidth = logoList.offsetWidth;
        let maxMove = Math.max(innerWidth - parentWidth, 0);
        let direction = i % 2 === 0 ? 1 : -1; // alternate direction

        gsap.set(logoList, {
          left: direction === 1 ? "100%" : `-${innerWidth}px`,
          opacity: 0
        });

        // logos move horizontally
        logoTl.to(logoList, {
          left: direction === 1 ? `-${maxMove}px` : "0%",
          opacity: 1,
          duration: 3,
          ease: "expo.out"
        }, 0);
      });

      // Insert sub-timeline slightly after text
      tl.add(logoTl, "+=0.5");
    } else {
      // text-only wrap: hold on screen briefly
      tl.to(wrap, {
        duration: 2, // hold text for a bit before fading out
      });
    }

    // Fade out except for last
    if (i !== logoWraps.length - 1) {
      tl.to(wrap, {
        opacity: 0,
        scale: 0.95,
        duration: 1,
        ease: "power3.inOut"
      }, "+=1");
    } else {
      // let last remain & unpin
      tl.to(logoSection, {
        pin: false,
        duration: 1,
        ease: "power2.out"
      }, "+=1");
    }
  });
}

sectionLogos(document.querySelector('.section_logo1'));

function animateFanSansType() {
  let section = document.querySelector('.section-typography .typography-fan-sans');

  let svg = section.querySelector('.fan-sans-svg')

  let blinker = section.querySelector(".type-blinker");

  let sansGroup = section.querySelector(".type-sans-group");
  let fansGroup = section.querySelector(".type-fans-group");

  let sansS = sansGroup.querySelector(".type-sans-s");
  let sansA = sansGroup.querySelector(".type-sans-a");
  let sansN = sansGroup.querySelector(".type-sans-n");
  let sansSTwo = sansGroup.querySelector(".type-sans-s2");

  let fansF = fansGroup.querySelector(".type-fans-f");
  let fansA = fansGroup.querySelector(".type-fans-a");
  let fansN = fansGroup.querySelector(".type-fans-n");
  let fansATwo = fansGroup.querySelector(".type-fans-a2");
  let fansT = fansGroup.querySelector(".type-fans-t");
  let fansI = fansGroup.querySelectorAll(".type-fans-i path");
  let fansC = fansGroup.querySelector(".type-fans-c");
  let fansS = fansGroup.querySelector(".type-fans-s");

  let logomark = fansGroup.querySelector(".type-fans-logomark");

  let typingTl = gsap.timeline({
    scrollTrigger: {
      trigger: svg,
      // scrub:true,
      // markers: true,
      start: "top 80%",
      toggleActions: "play pause resume reset"
    }
  });

  gsap.set(
    [
      sansS,
      sansA,
      sansN,
      sansSTwo,
      fansF,
      fansA,
      fansN,
      fansATwo,
      fansT,
      fansI,
      fansC,
      fansS,
      logomark,
      blinker
    ],
    {
      autoAlpha: 0
    }
  );

  typingTl.to(fansF, { autoAlpha: 1, duration: 0.2 })

    .to(fansA, { autoAlpha: 1, duration: 0.2 })

    .to(fansN, { autoAlpha: 1, duration: 0.2 })

    // type out Sans
    .to(sansS, { autoAlpha: 1, duration: 0.2 })
    .to(sansA, { autoAlpha: 1, duration: 0.2 })
    .to(sansN, { autoAlpha: 1, duration: 0.2 })
    .to(sansSTwo, { autoAlpha: 1, duration: 0.2 })

    // small pause
    .to({}, { duration: 0.5 });

  // delete Sans
  typingTl.to(sansSTwo, { autoAlpha: 0, duration: 0.2 })
    .to(sansN, { autoAlpha: 0, duration: 0.2 })
    .to(sansA, { autoAlpha: 0, duration: 0.2 })
    .to(sansS, { autoAlpha: 0, duration: 0.2 })

    .to({}, { duration: 0.5 });

  typingTl.to(fansATwo, { autoAlpha: 1, duration: 0.2 })
    .to(fansT, { autoAlpha: 1, duration: 0.2 })
    .to(fansI, { autoAlpha: 1, duration: 0.2 })
    .to(fansC, { autoAlpha: 1, duration: 0.2 })
    .to(fansS, { autoAlpha: 1, duration: 0.2 })

    // small pause
    .to({}, { duration: 0.5 });

  typingTl.to(logomark, {
    autoAlpha: 1,
    duration: 0.7
  });

  return typingTl;
}

// animateFanSansType()

let typographyRevealContent = document.querySelector(
  '.section-typography .text-reveal-typography-2');
revealText(typographyRevealContent);

function initColorPanels() {
  let panels = gsap.utils.toArray(".section-colors .color-panel");

  let tl = gsap.timeline({
    scrollTrigger: {
      // scroller: scrollContainer,
      trigger: ".section-colors .colors",
      pin: ".section-colors .colors-wrapper",
      pinSpacing: true,
      scrub: 1,
      onUpdate: (self) => {
        updateActivePanel(self.progress);
      },
      end: "+=" + panels.length * 1000 // Adjust scroll length

    }
  });

  function updateActivePanel(progress) {
    let activeIndex = Math.round(progress * panels.length - 0.5);

    // Ensure the last panel stays active at the end
    if (activeIndex >= panels.length - 1) {
      activeIndex = panels.length - 1; // Keep last panel active
    }

    panels.forEach((panel, index) => {
      if (index === activeIndex) {
        panel.classList.add("active");
      } else {
        panel.classList.remove("active");
      }
    });
  }

  panels.forEach((panel, index) => {
    let isLast = index === panels.length - 1;
    const nextPanel = isLast ? false : panels[index + 1];
    let currentContent = panel.querySelector(".colors-content");
    let nextContent = nextPanel ? nextPanel.querySelector(".colors-content") : null;
    if (!isLast) {

      tl.to(panel, {
        width: "5%",
        ease: "expo.out",
      });
      tl.to(currentContent, {
        clipPath: "inset(0 100% 0 0)", // from fully visible to clipped
        duration: 0.2,
        ease: "expo.inOut"
      }, "<")

      tl.to(nextPanel, {
        width: "100%", // Expand next panel
        ease: "expo.out",
        onStart: () => {
          nextPanel.classList.add("active")
          if (nextContent) {
            // currentContent.classList.remove("hide");
            // nextContent.classList.add("show"); // Add animation class
          }
        },
      }, "<"); // Sync animations
    } else {
      tl.to(panel, {
        width: "100%",
        duration: 0.5,
        ease: "expo.inOut"
      });
    }

  });

}

initColorPanels()

// better but first one breaks

// function stackedSlider(slider) {
//   const slides = slider.querySelectorAll(".stacked-slide");

//   function firstSlide() {
//     const slide = slides[0]
//     let currentTitle = slide.querySelector(".stacked-title");
//     let currentImg = slide.querySelector(".stacked-img");
//     let currentBody = slide.querySelector(".stacked-text-wrap");
//     const tl = gsap.timeline({
//       scrollTrigger: {
//         trigger: slides[0],
//         start: "top 50%", // Fade in before pinning starts
//         end: "top 20%",
//         scrub: 2,
//         // toggleActions: "play none none reset",

//         scroller: "body" // âœ… Ensure Lenis or default scroll works
//       }
//     })

//     tl.fromTo(currentImg, {
//       clipPath: "inset(100% 0% 0% 0%)"
//     }, {
//       clipPath: "inset(0% 0% 0% 0%)",
//       duration: 0.8
//     })

//     tl.fromTo(currentTitle, {
//       clipPath: "inset(0% 100% 0% 0%)"
//     }, {
//       clipPath: "inset(0% 0% 0% 0%)",
//     }, "<+=1")

//     tl.fromTo(currentBody, {
//       opacity: 0,
//       y: 50
//     }, {
//       opacity: 1,
//       y: 0
//     }, "<+=1")

//     // console.log(currentTitle)
//     // gsap.fromTo(currentImg, {
//     //   clipPath: "inset(0% 100% 0% 0%)"
//     // }, {
//     //   clipPath: "inset(0% 0% 0% 0%)",
//     //   scrollTrigger: {
//     //     trigger: currentImg,
//     //     markers: true,
//     //     start: "top 60%", // Fade in before pinning starts
//     //     end: "top 30%",
//     //     scrub: true,

//     //     scroller: "body" // âœ… Ensure Lenis or default scroll works
//     //   }
//     // })
//     // gsap.fromTo(currentTitle, {
//     //   clipPath: "inset(0% 100% 0% 0%)"
//     // }, {
//     //   clipPath: "inset(0% 0% 0% 0%)",
//     //   scrollTrigger: {
//     //     trigger: currentTitle,
//     //     markers: true,
//     //     start: "top 60%", // Fade in before pinning starts
//     //     end: "top 30%",
//     //     scrub: true,

//     //     scroller: "body" // âœ… Ensure Lenis or default scroll works
//     //   }
//     // })
//     // gsap.fromTo(
//     //   slides[0], { opacity: 0, y: 50 }, // Start position (hidden & slightly lower)
//     //   {
//     //     opacity: 1,
//     //     y: 0,
//     //     duration: 1,
//     //     ease: "power2.out",
//     //     scrollTrigger: {
//     //       trigger: slides[0],
//     //       start: "top 50%", // Fade in before pinning starts
//     //       end: "top 20%",
//     //       scrub: true,

//     //       scroller: "body" // âœ… Ensure Lenis or default scroll works
//     //     }
//     //   }
//     // );
//   }

//   firstSlide()

//   let tl = gsap.timeline({
//     scrollTrigger: {
//       trigger: slider,
//       pin: true,
//       scrub: 1,
//       start: "top top",
//       end: `+=${(slides.length - 1) * 2500}`
//     }
//   });

//   for (let i = 0; i < slides.length - 1; i++) {
//     let current = slides[i];
//     let next = slides[i + 1];

//     let currentImg = current.querySelector(".stacked-img");
//     let currentBody = current.querySelector(".stacked-text-wrap");
//     let currentTitle = current.querySelector(".stacked-title");

//     let nextImg = next.querySelector(".stacked-img");
//     let nextText = next.querySelector(".stacked-text-wrap");
//     let nextTitle = next.querySelector(".stacked-title");

//     if (i === 0) {
//       tl.to({}, { duration: .5 }); // Adds 1s delay before the first transition
//     }

//     // Animate current slide OUT
//     tl.to(currentImg, {
//         clipPath: "inset(100% 0% 0% 0%)",
//         duration: 0.5,
//         ease: "expo.out"
//       })
//       .to(currentTitle, {
//         opacity: 0,
//         duration: 0.5,
//         clipPath: "inset(0% 100% 0% 0%)",
//         ease: "expo.out",
//         scale: 1
//       }, "<")
//       .to(currentBody, {
//         opacity: 0,
//         y: -40,
//         duration: 0.5,
//         ease: "expo.out",
//         scale: 1
//       }, "<");

//     // Animate next slide IN
//     tl.fromTo(nextImg, {
//         clipPath: "inset(100% 0% 0% 0%)"
//       }, {
//         clipPath: "inset(0% 0% 0% 0%)",
//         duration: 0.5,
//         ease: "circ.out"
//       }, "<")
//       .fromTo(nextText, { opacity: 0, y: 40 }, {
//         opacity: 1,
//         y: 0,
//         duration: 0.5,
//         ease: "expo.out"
//       }, "<")
//       .to(next, {
//         zIndex: 1
//       }, "<")
//       .fromTo(nextTitle, {
//         // opacity: 0,
//         x: -20,
//         clipPath: "inset(0% 100% 0% 0%)"
//       }, {
//         clipPath: "inset(0% 0% 0% 0%)",
//         opacity: 1,
//         x: 0,
//         duration: 0.8,
//         ease: "expo.out"
//       }, "<0.15");
//   }
// }

// current
function stackedSlider(slider) {
  // const slides = gsap.utils.toArray(".stacked-slider .stacked-slide");
  const slides = slider.querySelectorAll(".stacked-slide")

  let tl = gsap.timeline({
    scrollTrigger: {
      // scroller: scrollContainer,
      trigger: slider,
      pin: true,
      scrub: 1,
      start: "top top",
      end: `+=${(slides.length - 1) * 1000}`,
      onLeave: () => {
        console.log('left')
      }
    }
  });

  for (let i = 0; i < slides.length - 1; i++) {
    let current = slides[i];
    let next = slides[i + 1];

    let currentImg = current.querySelector(".stacked-img");
    let currentBody = current.querySelector(".stacked-text-wrap");
    let currentTitle = current.querySelector(".stacked-title");

    let nextImg = next.querySelector(".stacked-img");
    let nextText = next.querySelector(".stacked-text-wrap");
    let nextTitle = next.querySelector(".stacked-title");

    // gsap.set(currentTitle, {

    // })

    // gsap.set(currentText.querySelector('.stacked-title'), {
    //   scale: 1.2,
    // })

    if (i === 0) {
      gsap.set(currentImg, {
        scale: 1.1
      })
      // console.log(currentImg)
      gsap.to(currentImg, {
        scale: 1, // Scale down to normal size (1) when entering the viewport
        duration: 1,
        scrollTrigger: {
          trigger: currentImg,
          start: "top 80%",
          end: "bottom 20%",
          scrub: true,
          // markers: true
        }
      });
    }

    // Animate current slide OUT
    // (clip from 0% => 100%, text fade up/out)
    tl.to(currentImg, {
        clipPath: "inset(100% 0% 0% 0%)",
        duration: 0.5,
        ease: "power4.out"
      })
      // .to(currentText.querySelector('.stacked-title'), {
      //   scale: 1,
      //   duration: .5
      // }, "<")
      .to(currentTitle, {
        opacity: .0,
        // moves text up
        duration: 0.5,
        clipPath: "inset(0% 100% 0% 0%)",
        // y: 40,
        // color: 'red',
        ease: "power4.out",
        scale: 1
      }, "<")

      .to(currentBody, {
        opacity: .0,
        y: -40, // moves text up
        duration: 0.5,
        ease: "power4.out",
        scale: 1
      }, "<");

    // Animate next slide IN
    // (clip from 100% => 0%, text fade in)
    tl.fromTo(nextImg, {
          clipPath: "inset(100% 0% 0% 0%)"

        }, // ensure it starts clipped
        {
          clipPath: "inset(0% 0% 0% 0%)",
          duration: 0.5,
          ease: "power4.out"
        },
        "<"
      )

      .fromTo(nextText, { opacity: 0, y: 40 }, // fade in from below
        {
          opacity: 1,
          y: 0,
          duration: 0.5,
          ease: "power4.out"
        },
        "<"
      )
      .to(next, {
        zIndex: 1
      }, "<")
      .fromTo(nextTitle, {
          opacity: 0,
          x: -20,
          clipPath: "inset(0% 100% 0% 0%)"
        }, // fade in from below
        {
          clipPath: "inset(0% 0% 0% 0%)",
          opacity: 1,
          x: 0,
          duration: 0.8,
          ease: "power4.out"
        },
        "<0.5"
      )
  }
}

let photographySlider = document.querySelector('.section-photography .stacked-slider')
stackedSlider(photographySlider)

function bigSlider(sliderWrapper) {
  let slider = sliderWrapper.querySelector('.big-slider')
  let slides = sliderWrapper.querySelectorAll('.big-slide')

  // console.log(slides)

  const ghostContainer = document.createElement("div");
  ghostContainer.className = "ghost_work-container";

  slider.appendChild(ghostContainer);

  const ghostItems = Array.from(slides).map(() => {
    const ghostItem = document.createElement("div");
    ghostItem.className = "ghost_work-item";
    ghostItem.style.cssText = "width: 100%; height: 250vh;";
    ghostContainer.appendChild(ghostItem);
    return ghostItem;
  });

  // Initial setup for work items
  gsap.set(slides, {
    position: "absolute",
    top: "0",
    left: "0",
    width: "100vw",
    height: "100vh",
    clipPath: "inset(0 0% 0 100%)"
  });

  ScrollTrigger.create({
    anticipatePin: 1,
    trigger: sliderWrapper,
    start: "top top",
    endTrigger: ghostContainer,
    end: "bottom bottom",
    pin: true,
    pinSpacing: false,
    // markers: true,
    onLeave: () => {
      sliderWrapper.style.height = "auto";
      setTimeout(() => {
        ghostContainer.remove();
      }, 100);
    }
  });

  const getBaseScrollTrigger = (ghostItem) => ({
    trigger: ghostItem,
    scrub: true,
    start: "top bottom",
    end: "+120vh top",
    // pin: true,
  });

  slides.forEach((element, i) => {
    const slideContainer = element.querySelector(".big-slide_inner");
    const slideBackground = element.querySelector(".big-slide_img-wrap");
    const slideOverlay = element.querySelector(".slide-overlay");
    const slideTitle = element.querySelector('.Impact-H1')

    // Initial states for background and title
    gsap.set(slideBackground, { scale: 1.4 });
    gsap.set(slideTitle, { scale: 1.1, xPercent: -20, opacity: 0 });

    // For the first slide, immediately reveal it:
    if (i === 0) {
      gsap.to(slideBackground, {
        scale: 1, // Scale down to normal size (1) when entering the viewport
        duration: 1,
        scrollTrigger: {
          trigger: element,
          start: "top 80%",
          end: "bottom 20%",
          scrub: true,
          // markers: true
        }
      });
      gsap.set(element, { clipPath: "inset(0 0 0 0%)" });
      gsap.set(slideContainer, { xPercent: 0 });
    } else {
      gsap.set(slideContainer, { xPercent: 40 });
      gsap.to(slideContainer, {
        xPercent: 0,
        scrollTrigger: getBaseScrollTrigger(ghostItems[i])
      });
      // gsap.to(element, {
      //   clipPath: "inset(0 0 0 0%)",
      //   ease: "back.out(1.7)",
      //   duration: 0.5,
      //   scrollTrigger: getBaseScrollTrigger(ghostItems[i])
      // });
      gsap.fromTo(
        element, { clipPath: "inset(0 0 0 100%)" },
        {
          clipPath: "inset(0 0 0 0%)",
          ease: "back.out(1.7)",
          duration: 0.5,
          scrollTrigger: getBaseScrollTrigger(ghostItems[i])
        }
      );
      gsap.to(slideContainer, {
        xPercent: 0,
        scrollTrigger: getBaseScrollTrigger(ghostItems[i])
      });
      gsap.to(slideBackground, {
        scale: 1,
        scrollTrigger: getBaseScrollTrigger(ghostItems[i])
      });
    }
  })

}

bigSlider(document.querySelector('.big-slider_from-fans'))

sectionLogos(document.querySelector('.section_icon-slide'));

let personalityAccordionWrapper = document.querySelector(
  '.section-personality .scroll-accordion-wrapper')
let personalityTitles = gsap.utils.toArray(
  ".section-personality .scroll-accordion-wrapper .accordion-title");
let personalityDefs = gsap.utils.toArray(
  ".section-personality .scroll-accordion-wrapper .definition");

scrollAccordion(personalityTitles, personalityDefs, personalityAccordionWrapper)

let voiceSlider = document.querySelector('.section-voice .stacked-slider')
stackedSlider(voiceSlider)

function initStoryPanels() {

  let panels = gsap.utils.toArray(".story-color-panel");

  // Create a master timeline, pinned for the entire sequence
  let tl = gsap.timeline({
    scrollTrigger: {
      // scroller: scrollContainer,
      trigger: ".story-accordion", // or any container you want pinned
      start: "top top",
      end: "+=2000", // adjust so there's enough space to see the animations
      pin: true,
      scrub: 1,
    }
  });

  // 1) Animate from the first (red) panel to the second panel normally
  //    so the user sees the transition more clearly.
  tl.to(panels[0], {
    height: "5rem",
    duration: 1,
    onStart: () => panels[0].classList.remove("active")
  });
  tl.to(panels[1], {
    height: "100%",
    duration: 1,
    onStart: () => panels[1].classList.add("active")
  }, "<");

  // 2) Animate the rest â€œfast.â€ Each panel shrinks in 0.2s, next expands in 0.2s
  //    so visually it all whips by quickly.
  for (let i = 1; i < panels.length - 1; i++) {
    tl.to(panels[i], {
      height: "5rem",
      duration: 0.2,
      onStart: () => panels[i].classList.remove("active")
    }, "+=0.1");
    tl.to(panels[i + 1], {
      height: "100%",
      duration: 0.2,
      onStart: () => panels[i + 1].classList.add("active")
    }, "<");
  }

}

initStoryPanels();

function initSliderScroll() {
  let sliderSection = document.querySelector(".scrolling-slider_section");
  let slidesContainer = document.querySelector('.scrolling-slider_slides');
  let slides = gsap.utils.toArray('.scrolling-slider_slide');
  let sliderHeader = sliderSection.querySelector('.heading-style-h1');

  let totalWidth = slidesContainer.scrollWidth;
  let parentWidth = slidesContainer.parentElement.offsetWidth;

  // âœ… Set initial states
  gsap.set(slides, { opacity: 0 }); // Fade in effect
  gsap.set(sliderHeader, { yPercent: 100, opacity: 0 });

  // âœ… Timeline for pinning + horizontal scroll
  let tl = gsap.timeline({
    scrollTrigger: {
      trigger: sliderSection,
      start: "top top",
      invalidateOnRefresh: true,
      end: `+=${(totalWidth - parentWidth) * 2}`, // ðŸ”¥ Extended scroll length
      pin: true,
      scrub: 3, // ðŸ”¥ Increased scrub to slow down movement
      // anticipatePin: 1,
      // markers: { startColor: "lime", endColor: "orange", fontSize: "16px" }

    }
  });

  // âœ… Header animation (separate from scrub)
  gsap.to(sliderHeader, {
    yPercent: 0,
    opacity: 1,
    duration: 1.2, // Slightly longer for better timing
    ease: "power4.out",
    delay: 0.15
  });

  // âœ… Slides fade in as they start moving
  tl.to(slides, {
    opacity: 1,
    duration: 1.5, // ðŸ”¥ Slightly longer fade-in
    stagger: 0.3, // ðŸ”¥ Slower stagger for smooth effect
    ease: "power2.out"
  }, "<");

  // âœ… Scroll slides to the left (Now takes longer)
  tl.to(slidesContainer, {
    x: `-${totalWidth - parentWidth}px`,
    duration: slides.length * 1.8, // ðŸ”¥ Slower slide movement
    ease: "power1.inOut"
  });

  // âœ… Unpin the section when done
  tl.to(sliderSection, {
    opacity: 1, // No fade-out, just unpin smoothly
    duration: 0.8
  });

}

initSliderScroll();

let headerReveal = document.querySelectorAll('[line-split]');
headerReveal.forEach((header, index) => {
  let split = new SplitText(header, {
    type: "lines",
    linesClass: "header-line"
  });

  gsap.set(header.querySelectorAll(".header-line"), {
    yPercent: 100,
    opacity: 0
  });

  let tl = gsap.timeline({
    scrollTrigger: {
      trigger: header,
      start: "top 70%", // When the top of the header hits 60% of the viewport height
      toggleActions: "play none none none",
      onLeaveBack: () => {
        tl.progress(0);
        tl.pause();
      }
    }
  });

  tl.to(header.querySelectorAll(".header-line"), {
    yPercent: 0,
    opacity: 1,
    duration: 1,
    ease: "power4.out",
    stagger: 0.2
  });

})

gsap.utils.toArray(".section-fade-up").forEach((section) => {
  gsap.fromTo(section, { opacity: 0, y: 50 }, // start
    {
      opacity: 1,
      y: 0,
      duration: .5,
      ease: "power2.out",
      scrollTrigger: {

        trigger: section,
        start: "top 80%", // reveal when near 80% viewport
        toggleActions: "play reverse play reverse",
        /*markers: true*/
      }
    }
  );
});

gsap.utils.toArray(".section-fade").forEach((section) => {
  gsap.fromTo(section, { opacity: 0 }, // start
    {
      opacity: 1,
      duration: 1,
      ease: "power2.out",
      scrollTrigger: {
        trigger: section,
        start: "top 80%", // reveal when near 80% viewport
        toggleActions: "play reverse play reverse"
      }
    }
  );
});

let headlineReveal = document.querySelectorAll('[headline-reveal]');

headlineReveal.forEach((header, index) => {
  const split = new SplitText(header, { type: "lines" });
  const lines = split.lines; // Get the split lines

  gsap.set(header, {
    scale: 0.9
  });

  gsap.set(lines, {
    color: "#E10600",
    opacity: 0,
    y: 30
  });

  let tl = gsap.timeline({
    scrollTrigger: {
      trigger: header,
      start: "top 85%",
      end: "top 30%",
      scrub: false,
      toggleActions: "play none none reset" // Replays on re-entering
    }
  });

  tl.to(lines, {
    opacity: 1,
    y: 0,
    duration: 0.5,
    ease: "power4.out",
    stagger: 0.12
  });

  tl.to(lines, {
    color: "#FFFFFF",
    stagger: 0.12
  }, "<");

  tl.to(header, {
    scale: 1,
    duration: 0.1,
    ease: "power1.out"
  });
});

const parallaxElements = document.querySelectorAll("[data-speed]");

parallaxElements.forEach((element) => {
  const speed = element.getAttribute("data-speed"); // Get speed from HTML attribute

  gsap.to(element, {
    y: `${speed * 100}px`, // Adjust movement based on speed
    ease: "none",
    scrollTrigger: {
      trigger: element,
      start: "top bottom",
      end: "bottom top",
      scrub: true,
      scroller: "body" // âœ… Ensures Lenis is used
    }
  });
});

// helpers 
window.addEventListener("resize", () => {
  setTextFadeMinHeight(lottieWrapper, lottieTextBlocks);
  setTimeout(() => {
    // ScrollTrigger.sort()
    ScrollTrigger.refresh();
  }, 300);
});

setTimeout(() => {
  setTextFadeMinHeight(lottieWrapper, lottieTextBlocks);
  ScrollTrigger.sort()
  ScrollTrigger.refresh();
}, 400);
// ScrollTrigger.refresh()

// window.addEventListener("resize", setTextFadeMinHeight);
ScrollTrigger.sort();
